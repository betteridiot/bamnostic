

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bamnostic.utils &mdash; bamnostic 1.2
 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/documentation_options.js?v=61243dd2"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            bamnostic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bamnostic.html">Module documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Citation and Support</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">bamnostic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bamnostic.utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bamnostic.utils</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">division</span>

<span class="sd">&quot;&quot;&quot;Module utilities and constants used throughout bamnostic</span>
<span class="sd">Copyright (c) 2018, Marcus D. Sherman</span>

<span class="sd">This code is part of the bamnostic distribution and governed by its</span>
<span class="sd">license.  Please see the LICENSE file that should have been included</span>
<span class="sd">as part of this package.</span>

<span class="sd">Some methods are modified versions of their counterparts</span>
<span class="sd">within the BioPython.bgzf module. Below is the Copyright and licensing</span>
<span class="sd">for those parts.</span>
<span class="sd">Copyright (c) 2010-2015 by Peter Cock.</span>

<span class="sd">Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<span class="sd">of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<span class="sd">in the Software without restriction, including without limitation the rights</span>
<span class="sd">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<span class="sd">copies of the Software, and to permit persons to whom the Software is</span>
<span class="sd">furnished to do so, subject to the following conditions:</span>

<span class="sd">The above copyright notice and this permission notice shall be included in all</span>
<span class="sd">copies or substantial portions of the Software.</span>

<span class="sd">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<span class="sd">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<span class="sd">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<span class="sd">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<span class="sd">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<span class="sd">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE</span>
<span class="sd">SOFTWARE.</span>

<span class="sd">@author: &quot;Marcus D. Sherman&quot;</span>
<span class="sd">@copyright: &quot;Copyright 2018, University of Michigan, Mills Lab</span>
<span class="sd">@email: &quot;mdsherman&lt;at&gt;betteridiot&lt;dot&gt;tech&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">struct</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">collections</span>

<span class="c1"># Python 2 doesn&#39;t put abstract base classes in the same spot as Python 3</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="n">_PY_VERSION</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span>
<span class="n">_is_pypy</span> <span class="o">=</span> <span class="s1">&#39;__pypy__&#39;</span> <span class="ow">in</span> <span class="n">sys</span><span class="o">.</span><span class="n">builtin_module_names</span>

<span class="k">if</span> <span class="n">_is_pypy</span><span class="p">:</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">__pypy__</span>

<span class="k">if</span> <span class="n">_PY_VERSION</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span> <span class="k">as</span> <span class="nb">dict</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numbers</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>


<div class="viewcode-block" id="format_warnings">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.format_warnings">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">format_warnings</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Sets STDOUT warnings</span>

<span class="sd">    Args:</span>
<span class="sd">        message: the unformatted warning message being reported</span>
<span class="sd">        category (str): the level of warning (handled by `warnings` module)</span>
<span class="sd">        filename (str): filename for logging purposes (defaults to STDOUT)</span>
<span class="sd">        lineno (int): where the error occurred.</span>

<span class="sd">    Returns:</span>
<span class="sd">        formatted warning string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">category</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span></div>


<span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span> <span class="o">=</span> <span class="n">format_warnings</span>

<span class="c1"># pre-compiled structures to reduce iterative unpacking</span>
<span class="n">unpack_int32</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span>
<span class="n">unpack_int32L</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">Struct</span><span class="p">(</span><span class="s1">&#39;&lt;l&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">unpack</span>


<span class="c1"># Helper class for performant named indexing of region of interests</span>
<div class="viewcode-block" id="Roi">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.Roi">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Roi</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Small __slots__ class for region of interest parsing&quot;&quot;&quot;</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__contig&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="s1">&#39;__tid&#39;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tid</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Initialize the class</span>

<span class="sd">        Args:</span>
<span class="sd">            contig (str): string representation of chromosome/contig of interest</span>
<span class="sd">            start (int): starting base position of region of interest</span>
<span class="sd">            stop (int): ending base position of region of interest</span>
<span class="sd">            tid (int): position of reference within the BAM header</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__contig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tid</span> <span class="o">=</span> <span class="n">contig</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">tid</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">contig</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__contig</span>

    <span class="nd">@contig</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">contig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__contig</span> <span class="o">=</span> <span class="n">ref_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__tid</span>

    <span class="nd">@tid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__tid</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">contig</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Roi(tid: </span><span class="si">{}</span><span class="s1">, start: </span><span class="si">{}</span><span class="s1">, stop: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">contig</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">tid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Roi(contig: </span><span class="si">{}</span><span class="s1">, start: </span><span class="si">{}</span><span class="s1">, stop: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;Roi(tid: </span><span class="si">{}</span><span class="s1">, contig: </span><span class="si">{}</span><span class="s1">, start: </span><span class="si">{}</span><span class="s1">, stop: </span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span></div>



<div class="viewcode-block" id="flag_decode">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.flag_decode">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">flag_decode</span><span class="p">(</span><span class="n">flag_code</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Simple read alignment flag decoder</span>

<span class="sd">    Every read within a BAM file ought to have an associated flag code. Theses</span>
<span class="sd">    flags are used for read filtering and QC. The flags are described below.</span>
<span class="sd">    Additionally, they can be found `here &lt;https://samtools.github.io/hts-specs/SAMv1.pdf&gt;`_</span>

<span class="sd">    Any given read&#39;s flag is determined by the *or* (`|`) operand of all appropriate bit flags.</span>

<span class="sd">    Args:</span>
<span class="sd">        flag_code (int): either a standalone integer/bit flag or the read object itself</span>

<span class="sd">    Returns:</span>
<span class="sd">        (:obj:`list` of :obj:`tuple`): list of flag and flag description tuples.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if provided flag is not a valid entry</span>

<span class="sd">    Example:</span>
<span class="sd">        If a flag is 516 it is comprised of flag 4 and flag 512</span>

<span class="sd">        &gt;&gt;&gt; flag_decode(516)</span>
<span class="sd">        [(4, &#39;read unmapped&#39;), (512, &#39;QC fail&#39;)]</span>

<span class="sd">    ====  =====  ==================================================================</span>
<span class="sd">    Int   Bit    Description</span>
<span class="sd">    ====  =====  ==================================================================</span>
<span class="sd">    1     0x1    Template having multiple segments in sequencing</span>
<span class="sd">    2     0x2    Each segment properly aligned according to the aligner</span>
<span class="sd">    4     0x4    Segment unmapped</span>
<span class="sd">    8     0x8    Next segment in the template unmapped</span>
<span class="sd">    16    0x10   SEQ being reverse complemented</span>
<span class="sd">    32    0x20   SEQ of the next segment in the template being reverse complemented</span>
<span class="sd">    64    0x40   The first segment in the template</span>
<span class="sd">    128   0x80   The last segment in the template</span>
<span class="sd">    256   0x100  Secondary alignment</span>
<span class="sd">    512   0x200  Not passing filters, such as platform/vendor quality controls</span>
<span class="sd">    1024  0x400  PCR or optical duplicate</span>
<span class="sd">    2048  0x800  Supplementary alignment</span>
<span class="sd">    ====  =====  ==================================================================</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="p">{</span><span class="mh">0x1</span><span class="p">:</span> <span class="s1">&#39;read paired&#39;</span><span class="p">,</span> <span class="mh">0x2</span><span class="p">:</span> <span class="s1">&#39;read mapped in proper pair&#39;</span><span class="p">,</span>
             <span class="mh">0x4</span><span class="p">:</span> <span class="s1">&#39;read unmapped&#39;</span><span class="p">,</span> <span class="mh">0x8</span><span class="p">:</span> <span class="s1">&#39;mate unmapped&#39;</span><span class="p">,</span>
             <span class="mh">0x10</span><span class="p">:</span> <span class="s1">&#39;read reverse strand&#39;</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">:</span> <span class="s1">&#39;mate reverse strand&#39;</span><span class="p">,</span>
             <span class="mh">0x40</span><span class="p">:</span> <span class="s1">&#39;first in pair&#39;</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">:</span> <span class="s1">&#39;second in pair&#39;</span><span class="p">,</span>
             <span class="mh">0x100</span><span class="p">:</span> <span class="s1">&#39;secondary alignment&#39;</span><span class="p">,</span> <span class="mh">0x200</span><span class="p">:</span> <span class="s1">&#39;QC fail&#39;</span><span class="p">,</span>
             <span class="mh">0x400</span><span class="p">:</span> <span class="s1">&#39;PCR or optical duplicate&#39;</span><span class="p">,</span> <span class="mh">0x800</span><span class="p">:</span> <span class="s1">&#39;supplementary alignment&#39;</span><span class="p">}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">flag_code</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">flag_code</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">code</span> <span class="o">=</span> <span class="n">flag_code</span><span class="o">.</span><span class="n">flag</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">code</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Integral</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Provided flag is not a valid entry&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">key</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">flags</span> <span class="k">if</span> <span class="n">key</span> <span class="o">&amp;</span> <span class="n">code</span><span class="p">])</span></div>



<div class="viewcode-block" id="yes_no">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.yes_no">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">yes_no</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Simple prompt parser&quot;&quot;&quot;</span>
    <span class="n">yes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;yes&#39;</span><span class="p">,</span> <span class="s1">&#39;ye&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>
    <span class="n">no</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;no&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s1">&#39;Would you like to continue? [y/n] &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">answer</span> <span class="ow">in</span> <span class="n">yes</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">answer</span> <span class="ow">in</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Please answer &quot;Yes&quot; or &quot;No&quot;&#39;</span><span class="p">)</span></div>



<span class="k">def</span><span class="w"> </span><span class="nf">filter_read</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">read_callback</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">):</span>

    <span class="c1"># Accept all reads</span>
    <span class="k">if</span> <span class="n">read_callback</span> <span class="o">==</span> <span class="s1">&#39;nofilter&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># check the read flags against filter criteria</span>
    <span class="k">elif</span> <span class="n">read_callback</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="n">read</span><span class="o">.</span><span class="n">flag</span> <span class="o">&amp;</span> <span class="mh">0x704</span>  <span class="c1"># hex for filter criteria flag bits</span>

    <span class="c1"># custom filter</span>
    <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">read_callback</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">read_callback</span><span class="p">(</span><span class="n">read</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;read_callback should be &quot;all&quot;, &quot;nofilter&quot;, or a custom function that returns a boolean&#39;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_parse_sam_region</span><span class="p">(</span><span class="n">region</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Splits and casts SAM-formatted regions&quot;&quot;&quot;</span>
    <span class="n">sam_region</span> <span class="o">=</span> <span class="s1">&#39;:&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">split</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>

    <span class="c1"># convert start and stop to integers</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sam_region</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">sam_region</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sam_region</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_handle_split_region</span><span class="p">(</span><span class="n">split_roi</span><span class="p">,</span> <span class="n">until_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Checks format against `until_eof` and creates the Roi object</span>

<span class="sd">    Args:</span>
<span class="sd">        split_roi (:py:obj:`list` or :py::obj:`tuple`): the contig, start, and stop information.</span>
<span class="sd">        until_eof (bool): whether or not to allow access to end of reference or file (whichever is first)</span>

<span class="sd">    Returns:</span>
<span class="sd">        (:py:obj:`bamnostic.utils.Roi`): region of interest formatted as an object with named attributes.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if `until_eof` is not set and region is open-ended or improper region format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">split_roi</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">split_roi</span><span class="p">)</span>
    <span class="c1"># make sure the user didn&#39;t put multiple positional arguments</span>
    <span class="k">if</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_roi</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>

        <span class="c1"># if the user gives an integer description of chromosome, convert to string</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">split_roi</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="n">split_roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">split_roi</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="kc">None</span> <span class="ow">in</span> <span class="n">split_roi</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="c1"># make sure the user wants to continue if they have used an open-ended region</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">until_eof</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Open-ended region while `until_eof` is set to False&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Roi</span><span class="p">(</span><span class="o">*</span><span class="n">split_roi</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;improper region format&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="parse_region">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.parse_region">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_region</span><span class="p">(</span><span class="n">contig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">tid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">until_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Parses region information from all user set parameters.</span>

<span class="sd">    The main goal of this function is to handle the many different ways a user</span>
<span class="sd">    can put in genomic region data. One way is through keyword arguments. This</span>
<span class="sd">    is the most straight forward. However, due to Pysam&#39;s API, there are multiple</span>
<span class="sd">    synonyms for reference/contig or stop/end. Additionally, if the user knows</span>
<span class="sd">    the refID/TID of the reference they are interested in, they can input that way</span>
<span class="sd">    as well.</span>

<span class="sd">    The second form a submission can take is through positional arguments. Just like</span>
<span class="sd">    keyword, but ordered such that it makes up a genomic region of interest.</span>

<span class="sd">    Note:</span>
<span class="sd">        Positional arguments make utilizing the `tid` parameter difficult since it is</span>
<span class="sd">        the 5th argument of the function signature.</span>

<span class="sd">    The third form a submission can take is through using a SAM-formatted string. An</span>
<span class="sd">    example SAM-formatted string looks like &#39;chr1:10-100&#39;. As many users also copy &amp;</span>
<span class="sd">    paste directly from tab-delimited files, such as BED files, a SAM-formatted string</span>
<span class="sd">    can take the form of &#39;chr1\\t10\\t100&#39; where &#39;\\t&#39; indicates a tab space.</span>

<span class="sd">    Lastly, the `until_eof` switch allows users to take all items from their desired</span>
<span class="sd">    start position (be it the whole reference or a specific spot on the reference). Setting</span>
<span class="sd">    this to `True` (default: `False`) will pull all reads to the end of the reference or file,</span>
<span class="sd">    whichever is first.</span>

<span class="sd">    Args:</span>
<span class="sd">        contig (str): name of reference/contig</span>
<span class="sd">        start (int): start position of region of interest (0-based)</span>
<span class="sd">        stop (int): stop position of region of interest (0-based)</span>
<span class="sd">        region (str): SAM region formatted string. Accepts tab-delimited values as well</span>
<span class="sd">        tid (int): the refID or target id of a reference/contig</span>
<span class="sd">        until_eof (bool): iterate until end of file (default: False)</span>

<span class="sd">    Returns:</span>
<span class="sd">        query (:py:class:`bamnostic.utils.Roi`): region of interest formatted as an object with named attributes.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if two synonym keywords are set, but contradict each other</span>

<span class="sd">    Examples:</span>
<span class="sd">        .. code-block:: python</span>

<span class="sd">            # Keyword-based</span>
<span class="sd">            &gt;&gt;&gt; parse_region(contig = &#39;chr1&#39;, start = 10, stop = 100)</span>
<span class="sd">            Roi(contig: chr1, start: 10, stop: 100)</span>

<span class="sd">            # Using `tid` instead of `contig`</span>
<span class="sd">            &gt;&gt;&gt; parse_region(tid = 0, start = 10, stop = 100)</span>
<span class="sd">            Roi(tid: 0, start: 10, stop: 100)</span>

<span class="sd">            # Positional arguments</span>
<span class="sd">            &gt;&gt;&gt; parse_region(&#39;chr1&#39;, 10, 100)</span>
<span class="sd">            Roi(contig: chr1, start: 10, stop: 100)</span>

<span class="sd">            # SAM-formatted string (keyword)</span>
<span class="sd">            &gt;&gt;&gt; parse_region(region = &#39;chr1:10-100&#39;)</span>
<span class="sd">            Roi(contig: chr1, start: 10, stop: 100)</span>

<span class="sd">            # SAM-formatted string (positional)</span>
<span class="sd">            &gt;&gt;&gt; parse_region(&#39;chr1:10-100&#39;)</span>
<span class="sd">            Roi(contig: chr1, start: 10, stop: 100)</span>

<span class="sd">            # Tab-delimited region string</span>
<span class="sd">            &gt;&gt;&gt; parse_region(&#39;chr1\t10\t100&#39;)</span>
<span class="sd">            Roi(contig: chr1, start: 10, stop: 100)</span>

<span class="sd">            # Contradictory synonyms</span>
<span class="sd">            &gt;&gt;&gt; parse_region(reference=&#39;chr1&#39;, contig=&#39;chr10&#39;, start=10, stop = 100)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">            ValueError: either contig or reference must be set, not both</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Check synonyms for the reference sequence</span>
    <span class="k">if</span> <span class="n">contig</span> <span class="ow">and</span> <span class="n">reference</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">contig</span> <span class="o">!=</span> <span class="n">reference</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;either contig or reference must be set, not both&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">contig</span> <span class="o">=</span> <span class="n">contig</span>
    <span class="k">elif</span> <span class="n">contig</span> <span class="ow">or</span> <span class="n">reference</span><span class="p">:</span>
        <span class="n">contig</span> <span class="o">=</span> <span class="n">contig</span> <span class="k">if</span> <span class="n">contig</span> <span class="k">else</span> <span class="n">reference</span>

    <span class="c1"># make sure the same thing isn&#39;t computed twice</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="ow">is</span> <span class="n">Roi</span><span class="p">:</span>  <span class="c1"># class defined in bamnostic.utils</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">contig</span>

    <span class="c1"># check for SAM-formatted regions or bed file format</span>
    <span class="k">elif</span> <span class="n">region</span> <span class="ow">or</span> <span class="p">(</span><span class="n">contig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="s1">&#39;:&#39;</span> <span class="ow">in</span> <span class="n">contig</span> <span class="ow">or</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span> <span class="ow">in</span> <span class="n">contig</span><span class="p">)):</span>
        <span class="n">roi</span> <span class="o">=</span> <span class="n">region</span> <span class="k">if</span> <span class="n">region</span> <span class="k">else</span> <span class="n">contig</span>
        <span class="n">query</span> <span class="o">=</span> <span class="n">_handle_split_region</span><span class="p">(</span><span class="n">_parse_sam_region</span><span class="p">(</span><span class="n">roi</span><span class="p">),</span> <span class="n">until_eof</span><span class="o">=</span><span class="n">until_eof</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">tid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">contig</span><span class="p">:</span>
            <span class="n">contig</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="ow">and</span> <span class="n">end</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stop</span> <span class="o">!=</span> <span class="n">end</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;either stop or end must be set, not both&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span> <span class="k">if</span> <span class="n">stop</span> <span class="k">else</span> <span class="n">end</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">_handle_split_region</span><span class="p">((</span><span class="n">contig</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">),</span> <span class="n">until_eof</span><span class="o">=</span><span class="n">until_eof</span><span class="p">)</span>

    <span class="n">query</span><span class="o">.</span><span class="n">tid</span> <span class="o">=</span> <span class="n">tid</span>

    <span class="k">return</span> <span class="n">query</span></div>



<div class="viewcode-block" id="unpack">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.unpack">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">_io</span><span class="p">,</span> <span class="n">is_array</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Utility function for unpacking binary data from file object or byte</span>
<span class="sd">    stream.</span>

<span class="sd">    The only difference between this method and `struct.unpack` is that</span>
<span class="sd">    `unpack` dynamically determines the size needed to read in based on</span>
<span class="sd">    the format string. Additionally, it can process a file object or byte</span>
<span class="sd">    stream and implement a read or slice (respectively). Mainly, this is a</span>
<span class="sd">    quality of life function.</span>

<span class="sd">    Args:</span>
<span class="sd">        fmt (str): the string format of the binary data to be unpacked</span>
<span class="sd">        _io: built-in binary format reader (default: io.BufferedRandom)</span>

<span class="sd">    Returns:</span>
<span class="sd">        unpacked contents from _io based on fmt string</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Unpack binary data safely. Returns None or empty tuple if _io is None</span>
    <span class="k">if</span> <span class="n">_io</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_array</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">size</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">calcsize</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># if it is byte object</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">_io</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="c1"># if it is a file object</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">unpack</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">size</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">is_array</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>



<div class="viewcode-block" id="make_virtual_offset">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.make_virtual_offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">make_virtual_offset</span><span class="p">(</span><span class="n">block_start_offset</span><span class="p">,</span> <span class="n">within_block_offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute a BGZF virtual offset from block start and within block offsets.</span>

<span class="sd">    The BAM indexing scheme records read positions using a 64 bit</span>
<span class="sd">    &#39;virtual offset&#39;, comprising in C terms:</span>

<span class="sd">    block_start_offset &lt;&lt; 16 | within_block_offset</span>

<span class="sd">    Here block_start_offset is the file offset of the BGZF block</span>
<span class="sd">    start (unsigned integer using up to 64-16 = 48 bits), and</span>
<span class="sd">    within_block_offset within the (decompressed) block (unsigned</span>
<span class="sd">    16 bit integer).</span>

<span class="sd">    &gt;&gt;&gt; make_virtual_offset(0, 0)</span>
<span class="sd">    0</span>

<span class="sd">    &gt;&gt;&gt; make_virtual_offset(0, 1)</span>
<span class="sd">    1</span>

<span class="sd">    &gt;&gt;&gt; make_virtual_offset(0, 2**16 - 1)</span>
<span class="sd">    65535</span>

<span class="sd">    &gt;&gt;&gt; make_virtual_offset(0, 2**16)</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    ...</span>
<span class="sd">    ValueError: Require 0 &lt;= within_block_offset &lt; 2**16, got 65536</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">within_block_offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">within_block_offset</span> <span class="o">&gt;=</span> <span class="mi">65536</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Require 0 &lt;= within_block_offset &lt; 2**16, got </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span>
                         <span class="n">within_block_offset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">block_start_offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">block_start_offset</span> <span class="o">&gt;=</span> <span class="mi">281474976710656</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Require 0 &lt;= block_start_offset &lt; 2**48, got </span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span>
                         <span class="n">block_start_offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">block_start_offset</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">|</span> <span class="n">within_block_offset</span></div>



<div class="viewcode-block" id="split_virtual_offset">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.split_virtual_offset">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">split_virtual_offset</span><span class="p">(</span><span class="n">virtual_offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Divides a 64-bit BGZF virtual offset into block start &amp; within block offsets.</span>

<span class="sd">    &gt;&gt;&gt; (100000, 0) == split_virtual_offset(6553600000)</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; (100000, 10) == split_virtual_offset(6553600010)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coffset</span> <span class="o">=</span> <span class="n">virtual_offset</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>
    <span class="n">uoffset</span> <span class="o">=</span> <span class="n">virtual_offset</span> <span class="o">^</span> <span class="p">(</span><span class="n">coffset</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">coffset</span><span class="p">,</span> <span class="n">uoffset</span></div>



<div class="viewcode-block" id="LruDict">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.LruDict">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">LruDict</span><span class="p">(</span><span class="n">OrderedDict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple least recently used (LRU) based dictionary that caches a given</span>
<span class="sd">    number of items.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize the dictionary based on collections.OrderedDict. This</span>
<span class="sd">        is built of the basic `OrderedDict`. The major difference in instantiation</span>
<span class="sd">        is the usage of the `max_cache` argument. This sets the dictionary size</span>
<span class="sd">        to be used.</span>

<span class="sd">        Args:</span>
<span class="sd">            items (iterable): an iterable object of key/value pairs</span>
<span class="sd">            max_cache (int): integer divisible by 2 to set max size of dictionary</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_cache</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;max_cache&#39;</span><span class="p">,</span> <span class="mi">128</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;mode&#39;</span><span class="p">,</span> <span class="s1">&#39;fifo&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;fifo&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">max_cache</span> <span class="o">=</span> <span class="mi">128</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mode</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># FIFO</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LruDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__map</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">_is_pypy</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pypy_move_to_end</span>
        <span class="k">elif</span> <span class="n">_PY_VERSION</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_py27_move_to_end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">LruDict</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">move_to_end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cull</span><span class="p">()</span>

<div class="viewcode-block" id="LruDict.get">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.LruDict.get">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Basic getter that renews LRU status upon inspection</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str): immutable dictionary key</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">value</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_pypy_move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">__pypy__</span><span class="o">.</span><span class="n">move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">last</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_py27_move_to_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move an existing element to the end (or beginning if last is false).</span>
<span class="sd">        Raise KeyError if the element does not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">link</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OrderedDict__map</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">link_prev</span><span class="p">,</span> <span class="n">link_next</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">link</span>

        <span class="n">soft_link</span> <span class="o">=</span> <span class="n">link_next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">link_prev</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_next</span>
        <span class="n">link_next</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">link_prev</span>
        <span class="n">root</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_OrderedDict__root</span>
        <span class="k">if</span> <span class="n">last</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">last</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">soft_link</span>
            <span class="n">last</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">first</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span>
            <span class="n">link</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">first</span>
            <span class="n">first</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">soft_link</span>
            <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">link</span>

<div class="viewcode-block" id="LruDict.update">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.LruDict.update">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Same as a regular `dict.update`, however, since pypy&#39;s `dict.update`</span>
<span class="sd">        doesn&#39;t go through `dict.__setitem__`, this is used to ensure it does</span>

<span class="sd">        Args:</span>
<span class="sd">            others (iterable): a dictionary or iterable containing key/value pairs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">others</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">others</span><span class="p">)</span> <span class="ow">in</span> <span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="n">k</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Iteratable/dict must be in key, value pairs&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="LruDict.cull">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.LruDict.cull">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">cull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Main utility function for pruning the LruDict</span>

<span class="sd">        If the length of the LruDict is more than `max_cache`, it removes the LRU item</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cache</span><span class="p">:</span>
            <span class="n">overflow</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_cache</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overflow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">overflow</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mode</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Basic setter that adds new item to dictionary, and then performs cull()</span>
<span class="sd">        to ensure max_cache has not been violated.</span>

<span class="sd">        Args:</span>
<span class="sd">            key (str): immutable dictionary key</span>
<span class="sd">            value (any): any dictionary value</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">OrderedDict</span><span class="o">.</span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cull</span><span class="p">()</span></div>


<span class="c1"># The BAM format uses byte encoding to compress alignment data. One such</span>
<span class="c1"># compression is how operations are stored: they are stored and an</span>
<span class="c1"># array of integers. These integers are mapped to their respective</span>
<span class="c1"># operation identifier. Below is the mapping utility.</span>
<span class="n">_CIGAR_OPS</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CMATCH&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
              <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CINS&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
              <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CDEL&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
              <span class="s1">&#39;N&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CREF_SKIP&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
              <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CSOFT_CLIP&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>
              <span class="s1">&#39;H&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CHARD_CLIP&#39;</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
              <span class="s1">&#39;P&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CPAD&#39;</span><span class="p">,</span> <span class="mi">6</span><span class="p">),</span>
              <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CEQUAL&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">),</span>
              <span class="s1">&#39;X&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CDIFF&#39;</span><span class="p">,</span> <span class="mi">8</span><span class="p">),</span>
              <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;BAM_CBACK&#39;</span><span class="p">,</span> <span class="mi">9</span><span class="p">)}</span>


<div class="viewcode-block" id="parse_cigar">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.parse_cigar">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">parse_cigar</span><span class="p">(</span><span class="n">cigar_str</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parses a CIGAR string and turns it into a list of tuples</span>

<span class="sd">    Args:</span>
<span class="sd">        cigar_str (str): the CIGAR string as shown in SAM entry</span>

<span class="sd">    Returns:</span>
<span class="sd">        cigar_array (list): list of tuples of CIGAR operations (by id) and number of operations</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if CIGAR operation is invalid</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; parse_cigar(&#39;3M1I3M1D5M&#39;) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">        [((&#39;BAM_CMATCH&#39;, 0), 3), ..., ((&#39;BAM_CMATCH&#39;, 0), 5)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cigar_array</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">cigar_op</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;n_op&gt;\d+)(?P&lt;op&gt;\w)&#39;</span><span class="p">,</span> <span class="n">cigar_str</span><span class="p">):</span>
        <span class="n">op_dict</span> <span class="o">=</span> <span class="n">cigar_op</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="n">n_ops</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">op_dict</span><span class="p">[</span><span class="s1">&#39;n_op&#39;</span><span class="p">])</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">_CIGAR_OPS</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">op_dict</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid CIGAR operation (</span><span class="si">{}</span><span class="s1">).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op_dict</span><span class="p">[</span><span class="s1">&#39;op&#39;</span><span class="p">]))</span>
        <span class="n">cigar_array</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">n_ops</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cigar_array</span></div>



<div class="viewcode-block" id="check_cigar_arg">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.check_cigar_arg">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_cigar_arg</span><span class="p">(</span><span class="n">cigar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Checks to make sure CIGAR arugment is valid.</span>

<span class="sd">    Args:</span>
<span class="sd">        argument (str or :py:obj:`list`): CIGAR string (pre-formatted or raw)</span>

<span class="sd">    Returns:</span>
<span class="sd">        (:py:obj:`list`): CIGAR re-formatted as a list</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if CIGAR is not a string or pre-formatted list</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">cigar</span> <span class="o">=</span> <span class="n">parse_cigar</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CIGAR must be string or list of tuples of cigar operations (by ID) and number of operations&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cigar</span></div>



<div class="viewcode-block" id="cigar_changes">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.cigar_changes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cigar_changes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">cigar</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recreates the reference sequence to the extent that the CIGAR string can</span>
<span class="sd">        represent.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq (str): aligned segment sequence</span>
<span class="sd">        cigar (list): list of tuples of cigar operations (by id) and number of operations</span>

<span class="sd">    Returns:</span>
<span class="sd">        cigar_formatted_ref (str): a version of the aligned segment&#39;s reference \</span>
<span class="sd">            sequence given the changes reflected in the cigar string</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if CIGAR operation is invalid</span>

<span class="sd">    Examples:</span>
<span class="sd">        &gt;&gt;&gt; cigar_changes(&#39;ACTAGAATGGCT&#39;, &#39;3M1I3M1D5M&#39;)</span>
<span class="sd">        &#39;ACTGAATGGCT&#39;</span>

<span class="sd">        &gt;&gt;&gt; cigar_changes(&#39;ACTAGAATGGCT&#39;, &#39;3V1I3M1D5M&#39;)</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">            ...</span>
<span class="sd">        ValueError: Invalid CIGAR operation (V).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cigar</span> <span class="o">=</span> <span class="n">check_cigar_arg</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
    <span class="n">cigar_formatted_ref</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">last_cigar_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">n_ops</span> <span class="ow">in</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">op_id</span> <span class="o">=</span> <span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}:</span>  <span class="c1"># matches (uses both sequence match &amp; mismatch)</span>
            <span class="n">cigar_formatted_ref</span> <span class="o">+=</span> <span class="n">seq</span><span class="p">[</span><span class="n">last_cigar_pos</span><span class="p">:</span><span class="n">last_cigar_pos</span> <span class="o">+</span> <span class="n">n_ops</span><span class="p">]</span>
            <span class="n">last_cigar_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">}:</span>  <span class="c1"># insertion or clips</span>
            <span class="n">last_cigar_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># intron or large gaps</span>
            <span class="n">cigar_formatted_ref</span> <span class="o">+=</span> <span class="s1">&#39;N&#39;</span> <span class="o">*</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">}:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid CIGAR string: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">cigar_formatted_ref</span></div>



<div class="viewcode-block" id="md_changes">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.md_changes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">md_changes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">md_tag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recreates the reference sequence of a given alignment to the extent that the</span>
<span class="sd">    MD tag can represent.</span>

<span class="sd">    Note:</span>
<span class="sd">        Used in conjunction with `cigar_changes` to recreate the</span>
<span class="sd">        complete reference sequence</span>

<span class="sd">    Args:</span>
<span class="sd">        seq (str): aligned segment sequence</span>
<span class="sd">        md_tag (str): MD tag for associated sequence</span>

<span class="sd">    Returns:</span>
<span class="sd">        ref_seq (str): a version of the aligned segment&#39;s reference sequence given \</span>
<span class="sd">            the changes reflected in the MD tag</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: if MD tag is None</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; md_changes(&#39;CTTATATTGGCCTT&#39;, &#39;3C4AT4&#39;)</span>
<span class="sd">        &#39;CTTCTATTATCCTT&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">md_tag</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No MD tag found or given for sequence&#39;</span><span class="p">)</span>
    <span class="n">ref_seq</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">last_md_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">mo</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;(?P&lt;matches&gt;\d+)|(?P&lt;del&gt;\^\w+?(?=\d))|(?P&lt;sub&gt;\w)&#39;</span><span class="p">,</span> <span class="n">md_tag</span><span class="p">):</span>
        <span class="n">mo_group_dict</span> <span class="o">=</span> <span class="n">mo</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;matches&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">matches</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;matches&#39;</span><span class="p">])</span>
            <span class="n">ref_seq</span> <span class="o">+=</span> <span class="n">seq</span><span class="p">[</span><span class="n">last_md_pos</span><span class="p">:</span><span class="n">last_md_pos</span> <span class="o">+</span> <span class="n">matches</span><span class="p">]</span>
            <span class="n">last_md_pos</span> <span class="o">+=</span> <span class="n">matches</span>
        <span class="k">elif</span> <span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;del&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">deletion</span> <span class="o">=</span> <span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;del&#39;</span><span class="p">]</span>
            <span class="n">ref_seq</span> <span class="o">+=</span> <span class="n">deletion</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">elif</span> <span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;sub&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">substitution</span> <span class="o">=</span> <span class="n">mo_group_dict</span><span class="p">[</span><span class="s1">&#39;sub&#39;</span><span class="p">]</span>
            <span class="n">ref_seq</span> <span class="o">+=</span> <span class="n">substitution</span>
            <span class="n">last_md_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="n">ref_seq</span></div>



<div class="viewcode-block" id="ref_gen">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.ref_gen">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ref_gen</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">cigar_string</span><span class="p">,</span> <span class="n">md_tag</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Recreates the reference sequence associated with the given segment.</span>

<span class="sd">    Uses the CIGAR string and MD tag to recreate the reference sequence associated</span>
<span class="sd">    with the aligned segment. This is done without the need for looking up</span>
<span class="sd">    the reference genome. Example reads, MD tags, and CIGAR strings taken from</span>
<span class="sd">    `David Tang&#39;s Blog`_.</span>

<span class="sd">    .. _David Tang&#39;s Blog: https://davetang.org/muse/2011/01/28/perl-and-sam/</span>

<span class="sd">    Returns:</span>
<span class="sd">        (str): generated reference sequence</span>

<span class="sd">    Raises:</span>
<span class="sd">        KeyError: if read does not contain MD tag</span>

<span class="sd">    Examples:</span>
<span class="sd">        # Only mismatches</span>
<span class="sd">        &gt;&gt;&gt; seq = &#39;CGATACGGGGACATCCGGCCTGCTCCTTCTCACATG&#39;</span>
<span class="sd">        &gt;&gt;&gt; cigar = &#39;36M&#39;</span>
<span class="sd">        &gt;&gt;&gt; md = &#39;1A0C0C0C1T0C0T27&#39;</span>
<span class="sd">        &gt;&gt;&gt; ref_gen(seq, cigar, md)</span>
<span class="sd">        &#39;CACCCCTCTGACATCCGGCCTGCTCCTTCTCACATG&#39;</span>

<span class="sd">        # Insertions and mismatches</span>
<span class="sd">        &gt;&gt;&gt; seq = &#39;GAGACGGGGTGACATCCGGCCTGCTCCTTCTCACAT&#39;</span>
<span class="sd">        &gt;&gt;&gt; cigar = &#39;6M1I29M&#39;</span>
<span class="sd">        &gt;&gt;&gt; md = &#39;0C1C0C1C0T0C27&#39;</span>
<span class="sd">        &gt;&gt;&gt; ref_gen(seq, cigar, md)</span>
<span class="sd">        &#39;CACCCCTCTGACATCCGGCCTGCTCCTTCTCACAT&#39;</span>

<span class="sd">        # Deletion and mismatches</span>
<span class="sd">        &gt;&gt;&gt; seq = &#39;AGTGATGGGGGGGTTCCAGGTGGAGACGAGGACTCC&#39;</span>
<span class="sd">        &gt;&gt;&gt; cigar = &#39;9M9D27M&#39;</span>
<span class="sd">        &gt;&gt;&gt; md = &#39;2G0A5^ATGATGTCA27&#39;</span>
<span class="sd">        &gt;&gt;&gt; ref_gen(seq, cigar, md)</span>
<span class="sd">        &#39;AGGAATGGGATGATGTCAGGGGTTCCAGGTGGAGACGAGGACTCC&#39;</span>

<span class="sd">        # Insertion, deletion, and mismatches</span>
<span class="sd">        &gt;&gt;&gt; seq = &#39;AGTGATGGGAGGATGTCTCGTCTGTGAGTTACAGCA&#39;</span>
<span class="sd">        &gt;&gt;&gt; cigar = &#39;2M1I7M6D26M&#39;</span>
<span class="sd">        &gt;&gt;&gt; md = &#39;3C3T1^GCTCAG26&#39;</span>
<span class="sd">        &gt;&gt;&gt; ref_gen(seq, cigar, md)</span>
<span class="sd">        &#39;AGGCTGGTAGCTCAGGGATGTCTCGTCTGTGAGTTACAGCA&#39;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">md_changes</span><span class="p">(</span><span class="n">cigar_changes</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">cigar_string</span><span class="p">),</span> <span class="n">md_tag</span><span class="p">)</span></div>



<div class="viewcode-block" id="cigar_alignment">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.utils.cigar_alignment">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">cigar_alignment</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cigar</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start_pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qualities</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_qual_thresh</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">query</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Use the CIGAR to filter out all unaligned data bases</span>

<span class="sd">    Any clipping results in the removal of those bases. If an insertion is seen in</span>
<span class="sd">    the CIGAR, those bases are removed from the sequence. If a deletion is seen in</span>
<span class="sd">    the CIGAR, those bases are padded with a period (&#39;.&#39;) symbol.</span>

<span class="sd">    Args:</span>
<span class="sd">        seq (str): string sequence of the aligned segment.</span>
<span class="sd">        cigar (str): the cigar string or `cigartuple` of the aligned segment.</span>
<span class="sd">        start_pos (int): the first aligned position of the read</span>
<span class="sd">        qualities (:py:obj:`array.array`): base quality array from read</span>

<span class="sd">    Yields:</span>
<span class="sd">        (:py:obj:`tuple` of :py:obj:`str` and :py:obj:`int`): nucleotide base and index position of that base relative to reference</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; seq = &#39;AGTGATGGGAGGATGTCTCGTCTGTGAGTTACAGCA&#39;</span>
<span class="sd">        &gt;&gt;&gt; cigar = &#39;2M1I7M6D26M&#39;</span>
<span class="sd">        &gt;&gt;&gt; start_position = 95</span>
<span class="sd">        &gt;&gt;&gt; c_a = cigar_alignment(seq, cigar, start_position)</span>
<span class="sd">        &gt;&gt;&gt; next(c_a)</span>
<span class="sd">        (&#39;A&#39;, 95)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">cigar</span> <span class="o">=</span> <span class="n">check_cigar_arg</span><span class="p">(</span><span class="n">cigar</span><span class="p">)</span>
    <span class="n">cigar_aligned</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">algn_seg</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">last_cigar_pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">op</span><span class="p">,</span> <span class="n">n_ops</span> <span class="ow">in</span> <span class="n">cigar</span><span class="p">:</span>
        <span class="n">op_id</span> <span class="o">=</span> <span class="n">op</span> <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">op</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">int</span> <span class="k">else</span> <span class="n">op</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op_id</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>  <span class="c1"># BAM_CHARD_CLIP: skip hard clip CIGAR ops</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">}:</span>  <span class="c1"># BAM_CINS or BAM_CSOFT_CLIP: remove from sequence</span>
            <span class="k">if</span> <span class="n">query</span> <span class="ow">and</span> <span class="n">op_id</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">seg_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">last_cigar_pos</span><span class="p">:</span><span class="n">last_cigar_pos</span> <span class="o">+</span> <span class="n">n_ops</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">qualities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">seg_qual</span> <span class="o">=</span> <span class="n">qualities</span><span class="p">[</span><span class="n">last_cigar_pos</span><span class="p">:</span><span class="n">last_cigar_pos</span> <span class="o">+</span> <span class="n">n_ops</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seg_seq</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">qualities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">seg_qual</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">base_qual_thresh</span><span class="p">:</span>
                            <span class="k">yield</span> <span class="n">base</span><span class="p">,</span> <span class="n">start_pos</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">base</span><span class="p">,</span> <span class="n">start_pos</span>
            <span class="n">last_cigar_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>  <span class="c1"># BAM_CREF_SKIP: intron or large gaps</span>
            <span class="n">start_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># BAM_CDEL: pad for deletions</span>
            <span class="n">start_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">elif</span> <span class="n">op_id</span> <span class="ow">in</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">}:</span>  <span class="c1"># matches (uses both sequence match &amp; mismatch)</span>
            <span class="n">seg_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">last_cigar_pos</span><span class="p">:</span><span class="n">last_cigar_pos</span> <span class="o">+</span> <span class="n">n_ops</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">qualities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seg_qual</span> <span class="o">=</span> <span class="n">qualities</span><span class="p">[</span><span class="n">last_cigar_pos</span><span class="p">:</span><span class="n">last_cigar_pos</span> <span class="o">+</span> <span class="n">n_ops</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seg_seq</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">qualities</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">seg_qual</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">base_qual_thresh</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">base</span><span class="p">,</span> <span class="n">start_pos</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">base</span><span class="p">,</span> <span class="n">start_pos</span>
                <span class="n">start_pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">last_cigar_pos</span> <span class="o">+=</span> <span class="n">n_ops</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid CIGAR string: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">op</span><span class="p">))</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Marcus D. Sherman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>