

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bamnostic.bam &mdash; bamnostic 1.2
 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/documentation_options.js?v=61243dd2"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            bamnostic
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bamnostic.html">Module documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../support.html">Citation and Support</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">bamnostic</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bamnostic.bam</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bamnostic.bam</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">absolute_import</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">division</span>

<span class="sd">&quot;&quot;&quot;Modified version of BioPython.bgzf module. Includes LRU buffer dictionary.</span>
<span class="sd">Copyright (c) 2018, Marcus D. Sherman</span>

<span class="sd">This code is part of the bamnostic distribution and governed by its</span>
<span class="sd">license.  Please see the LICENSE file that should have been included</span>
<span class="sd">as part of this package.</span>

<span class="sd">Some methods are modified versions of their counterparts within the BioPython.bgzf</span>
<span class="sd"> module. BioPython BGZF is now under a 3-clause BSD license. The same license </span>
<span class="sd">found in this package. Refer to LICENSE for information.</span>
<span class="sd">Copyright (c) 2010-2015 by Peter Cock.</span>

<span class="sd">Description: Read and write BGZF compressed files (the GZIP variant used in BAM).</span>
<span class="sd">Significant changes were made to the original BGZF module, produced by</span>
<span class="sd">Peter Cock. Aside from adding an LRU dictionary, the new BGZF module can read</span>
<span class="sd">BAM files directly, decompressing and unpacking the byte-encoded data structure</span>
<span class="sd">outlined in the BAM_ format.</span>

<span class="sd">.. _BAM: https://samtools.github.io/hts-specs/SAMv1.pdf</span>

<span class="sd">@author: &quot;Marcus D. Sherman&quot;</span>
<span class="sd">@copyright: &quot;Copyright 2018, University of Michigan, Mills Lab</span>
<span class="sd">@email: &quot;mdsherman&lt;at&gt;betteridiot&lt;dot&gt;tech&quot;</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">struct</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">io</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">array</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">bamnostic</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bamnostic</span><span class="w"> </span><span class="kn">import</span> <span class="n">bgzf</span><span class="p">,</span> <span class="n">bai</span><span class="p">,</span> <span class="n">csi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">bamnostic.utils</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="n">_PY_VERSION</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span>

<span class="k">if</span> <span class="n">_PY_VERSION</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="nb">open</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_format_warnings</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">category</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Warning formatter</span>

<span class="sd">    Args:</span>
<span class="sd">        message: warning message</span>
<span class="sd">        category (str): level of warning</span>
<span class="sd">        filename (str): path for warning output</span>
<span class="sd">        lineno (int): Where the warning originates</span>

<span class="sd">    Returns:</span>
<span class="sd">        Formatted warning for logging purposes</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s1">&#39; </span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">:</span><span class="si">{}</span><span class="s1">: </span><span class="si">{}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">category</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">message</span><span class="p">)</span>


<span class="n">warnings</span><span class="o">.</span><span class="n">formatwarning</span> <span class="o">=</span> <span class="n">_format_warnings</span>


<div class="viewcode-block" id="BAMheader">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BAMheader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BAMheader</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Parse and store the BAM file header</span>

<span class="sd">    The BAM header is the plain text and byte-encoded metadata of a given BAM file.</span>
<span class="sd">    Information stored in the header are the number, length, and name of the reference</span>
<span class="sd">    sequences that reads were aligned to; version of software used; read group identifiers; etc.</span>
<span class="sd">    The BAM_ format also stipulates that the first block of any BAM file should be reserved</span>
<span class="sd">    just for the BAM header block.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        _io (:py:obj:`file`): opened BAM file object</span>
<span class="sd">        SAMheader (:py:obj:`dict`): parsed dictionary of the SAM header</span>
<span class="sd">        n_refs (int): number of references</span>
<span class="sd">        refs (:py:obj:`dict`): reference names and lengths listed in the BAM header</span>

<span class="sd">    .. _BAM: https://samtools.github.io/hts-specs/SAMv1.pdf</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;_magic&#39;</span><span class="p">,</span> <span class="s1">&#39;_header_length&#39;</span><span class="p">,</span> <span class="s1">&#39;_header_block&#39;</span><span class="p">,</span> <span class="s1">&#39;_SAMheader_raw&#39;</span><span class="p">,</span>
                 <span class="s1">&#39;_SAMheader_end&#39;</span><span class="p">,</span> <span class="s1">&#39;SAMheader&#39;</span><span class="p">,</span> <span class="s1">&#39;n_refs&#39;</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">,</span> <span class="s1">&#39;_BAMheader_end&#39;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_io</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initialize the header</span>

<span class="sd">        Args:</span>
<span class="sd">            _io (:py:obj:`file`): opened BAM file object</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if BAM magic line not found at the top of the file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">magic</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_length</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;4si&#39;</span><span class="p">,</span> <span class="n">_io</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">magic</span> <span class="o">!=</span> <span class="sa">b</span><span class="s1">&#39;BAM</span><span class="se">\x01</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect BAM magic line. File head may be unaligned or this is not a BAM file&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># If SAM header is present, it is in plain text. Process it and save it as rows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;</span><span class="si">{}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header_length</span><span class="p">),</span> <span class="n">_io</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SAMheader</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;@&#39;</span><span class="p">):</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">fields_dict</span> <span class="o">=</span> <span class="p">{}</span>
                    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">fields</span><span class="p">:</span>
                        <span class="n">split_field</span> <span class="o">=</span> <span class="n">field</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">split_field</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="n">tag</span> <span class="o">=</span> <span class="n">split_field</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">split_field</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">tag</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">split_field</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
                        <span class="n">fields_dict</span><span class="p">[</span><span class="n">tag</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">SAMheader</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fields_dict</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">SAMheader</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_end</span> <span class="o">=</span> <span class="n">_io</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="c1"># Each reference is listed with the @SQ tag. We need the number of refs to process the data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_refs</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;&lt;i&#39;</span><span class="p">,</span> <span class="n">_io</span><span class="p">)</span>

        <span class="c1"># create a dictionary of all the references and their lengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">refs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_refs</span><span class="p">):</span>
            <span class="n">name_len</span> <span class="o">=</span> <span class="n">unpack_int32</span><span class="p">(</span><span class="n">_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ref_name</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">s&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">name_len</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># get rid of null: \x00</span>
            <span class="n">ref_len</span> <span class="o">=</span> <span class="n">unpack_int32</span><span class="p">(</span><span class="n">_io</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">r</span><span class="p">:</span> <span class="p">(</span><span class="n">ref_name</span><span class="o">.</span><span class="n">decode</span><span class="p">(),</span> <span class="n">ref_len</span><span class="p">)})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_BAMheader_end</span> <span class="o">=</span> <span class="n">_io</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header_block</span> <span class="o">=</span> <span class="n">bgzf</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">_io</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="BAMheader.to_header">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BAMheader.to_header">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">to_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Allows the user to directly copy the header of another BAM file</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bytesarray): packed byte code of entire header BGZF block</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_block</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Used as a synonym for printing by calling the object directly</span>

<span class="sd">        Note:</span>
<span class="sd">            Preferentially prints out the SAM header (if present). Otherwise, it will print</span>
<span class="sd">            the string representation of the BAM header dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">refs</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Used for printing the header</span>

<span class="sd">        Note:</span>
<span class="sd">            Preferentially prints out the SAM header (if present). Otherwise, it will print</span>
<span class="sd">            the string representation of the BAM header dictionary</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_SAMheader_raw</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">refs</span><span class="p">)</span></div>



<div class="viewcode-block" id="BamReader">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BamReader</span><span class="p">(</span><span class="n">bgzf</span><span class="o">.</span><span class="n">BgzfReader</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; The BAM reader. Heavily modified from Peter Cock&#39;s BgzfReader.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        header: representation of header data (if present)</span>
<span class="sd">        lengths (:py:obj:`list` of :py:obj:`int`): lengths of references listed in header</span>
<span class="sd">        nocoordinate (int): number of reads that have no coordinates</span>
<span class="sd">        nreferences (int): number of references in header</span>
<span class="sd">        ref2tid (:py:obj:`dict` of :py:obj:`str`, :py:obj:`int`): refernce names and refID dictionary</span>
<span class="sd">        references (:py:obj:`list` of :py:obj:`str`): names of references listed in header</span>
<span class="sd">        text (str): SAM header (if present)</span>
<span class="sd">        unmapped (int): number of unmapped reads</span>

<span class="sd">    Note:</span>
<span class="sd">        This implementation is likely to change. While the API was meant to</span>
<span class="sd">        mirror `pysam`, it makes sense to include the `pysam`-like API in an extension</span>
<span class="sd">        that will wrap the core reader. This would be a major refactor, and therefore</span>
<span class="sd">        will not happen any time soon (30 May 2018).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rb&quot;</span><span class="p">,</span> <span class="n">max_cache</span><span class="o">=</span><span class="mi">128</span><span class="p">,</span> <span class="n">index_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">check_header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">check_sq</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">reference_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">filepath_index</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">require_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">duplicate_filehandle</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ignore_truncation</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the class.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath_or_object (str | :py:obj:`file`): the path or file object of the BAM file</span>
<span class="sd">            mode (str): Mode for reading. BAM files are binary by nature (default: &#39;rb&#39;).</span>
<span class="sd">            max_cache (int): number of desired LRU cache size, preferably a multiple of 2 (default: 128).</span>
<span class="sd">            index_filename (str): path to index file (BAI) if it is named differently than the BAM file (default: None).</span>
<span class="sd">            filename (str | :py:obj:`file`): synonym for `filepath_or_object`</span>
<span class="sd">            check_header (bool): Obsolete method maintained for backwards compatibility (default: False)</span>
<span class="sd">            check_sq (bool): Inspect BAM file for `@SQ` entries within the header</span>
<span class="sd">            reference_filename (str): Not implemented. Maintained for backwards compatibility</span>
<span class="sd">            filepath_index (str): synonym for `index_filename`</span>
<span class="sd">            require_index (bool): require the presence of an index file or raise (default: False)</span>
<span class="sd">            duplicate_filehandle (bool): Not implemented. Raises warning if True.</span>
<span class="sd">            ignore_truncation (bool): Whether or not to allow trucated file processing (default: False).</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># # Connect to the BAM file</span>
        <span class="c1"># self._handle = handle</span>
        <span class="n">super_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;filepath_or_object&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;filepath_or_object&#39;</span><span class="p">],</span> 
                    <span class="s1">&#39;mode&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;mode&#39;</span><span class="p">],</span> <span class="s1">&#39;max_cache&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;max_cache&#39;</span><span class="p">],</span>
                    <span class="s1">&#39;filename&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;filename&#39;</span><span class="p">],</span> <span class="s1">&#39;ignore_truncation&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;ignore_truncation&#39;</span><span class="p">],</span> 
                    <span class="s1">&#39;duplicate_filehandle&#39;</span><span class="p">:</span> <span class="nb">locals</span><span class="p">()[</span><span class="s1">&#39;duplicate_filehandle&#39;</span><span class="p">]}</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BamReader</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">**</span><span class="n">super_args</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_truncation</span> <span class="o">=</span> <span class="n">ignore_truncation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_truncation</span><span class="p">()</span>

        <span class="c1"># Check BAM file integrity</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ignore_truncation</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;BAM file may be truncated. Turn off ignore_truncation if you wish to continue&#39;</span><span class="p">)</span>

        <span class="c1"># Connect and process the Index file (if present)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index_ext</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">filepath_index</span> <span class="ow">and</span> <span class="n">index_filename</span> <span class="ow">and</span> <span class="n">index_filename</span> <span class="o">!=</span> <span class="n">filepath_index</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Use index_filename or filepath_or_object. Not both&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_index</span><span class="p">(</span><span class="n">index_filename</span> <span class="k">if</span> <span class="n">index_filename</span> <span class="k">else</span> <span class="n">filepath_index</span><span class="p">,</span> <span class="n">require_index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_index</span><span class="p">()</span>

        <span class="c1"># Load in the BAM header as an instance attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_load_header</span><span class="p">(</span><span class="n">check_sq</span><span class="p">)</span>

        <span class="c1"># Helper dictionary for changing reference names to refID/TID</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref2tid</span> <span class="o">=</span> <span class="p">{</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="c1"># Final exception handling</span>
        <span class="k">if</span> <span class="n">check_header</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Obsolete method&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">duplicate_filehandle</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;duplicate_filehandle not necessary as the C API for samtools is not used&#39;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_filename</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;CRAM file support not yet implemented&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BamReader.check_index">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.check_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">check_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index_filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">req_idx</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Checks to make sure index file is available. If not, it disables random access.</span>

<span class="sd">        Args:</span>
<span class="sd">            index_filename (str): path to index file (BAI) if it does not fit naming convention (default: None).</span>
<span class="sd">            req_idx (bool): Raise error if index file is not present (default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): True if index is present, else False</span>

<span class="sd">        Raises:</span>
<span class="sd">            IOError: If the index file is closed or index could not be opened</span>

<span class="sd">        Warns:</span>
<span class="sd">            UserWarning: If index could not be loaded. Random access is disabled.</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam)</span>
<span class="sd">            &gt;&gt;&gt; bam.check_index(bamnostic.example_bam + &#39;.bai&#39;)</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; bam.check_index(&#39;not_a_file.bai&#39;)</span>
<span class="sd">            False</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">index_filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;csi&#39;</span><span class="p">,</span> <span class="s1">&#39;bai&#39;</span><span class="p">):</span>
                <span class="n">possible_index_path</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1">.</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">name</span><span class="p">),</span> <span class="n">ext</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">possible_index_path</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span> <span class="o">=</span> <span class="n">possible_index_path</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_random_access</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_index_ext</span> <span class="o">=</span> <span class="n">ext</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">req_idx</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;htsfile is closed or index could not be opened&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;No supplied index file was not found. Random access disabled&quot;</span><span class="p">,</span> <span class="ne">UserWarning</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_random_access</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">index_filename</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span> <span class="o">=</span> <span class="n">index_filename</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_random_access</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index_ext</span> <span class="o">=</span> <span class="n">index_filename</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">req_idx</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;htsfile is closed or index could not be opened&#39;</span><span class="p">)</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Index file &#39;</span><span class="si">{}</span><span class="s2">&#39; was not found. Random access disabled&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index_filename</span><span class="p">),</span> <span class="ne">UserWarning</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_random_access</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">return</span> <span class="kc">False</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_init_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the index file (BAI)&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span><span class="p">:</span>
            <span class="c1"># self._index = bamnostic.bai.Bai(self._index_path)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_ext</span> <span class="o">==</span> <span class="s2">&quot;csi&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">csi</span><span class="o">.</span><span class="n">Csi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_ext</span> <span class="o">==</span> <span class="s2">&quot;bai&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span> <span class="o">=</span> <span class="n">bai</span><span class="o">.</span><span class="n">Bai</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">n_no_coor</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__mapped</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span><span class="p">[</span><span class="n">mapped</span><span class="p">]</span><span class="o">.</span><span class="n">n_mapped</span>
                <span class="k">for</span> <span class="n">mapped</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span>
            <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__unmapped</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span><span class="p">[</span><span class="n">unmapped</span><span class="p">]</span><span class="o">.</span><span class="n">n_unmapped</span>
                <span class="k">for</span> <span class="n">unmapped</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span>
            <span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nocoordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of reads without coordiantes according to the statistics recorded in the index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): sum of reads without coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mapped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of mapped reads according  to the statistics recorded in the index.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): sum of mapped reads</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mapped</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">unmapped</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get the number of unmapped reads without coordiantes **and**</span>
<span class="sd">        without coordinate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): sum of unmapped reads and reads without coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__unmapped</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nocoordinate</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_sq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Inspect BAM file for @SQ entries within the header</span>

<span class="sd">        The implementation of this check is for BAM files specifically. I inspects</span>
<span class="sd">        the SAM header (if present) for the `@SQ` entires. However, if the SAM header</span>
<span class="sd">        is not present, will inspect the BAM header for reference sequence entries. If this</span>
<span class="sd">        test ever returns `FALSE`, the BAM file is not operational.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): True if present, else false</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam._check_sq()</span>
<span class="sd">            True</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_header_length</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;SQ&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">SAMheader</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">check_sq</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Loads the header into the reader object</span>

<span class="sd">        Args:</span>
<span class="sd">            check_sq (bool): whether to check for file header or not (default: True).</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: If &#39;SQ&#39; entry is not present in BAM header</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_header</span> <span class="o">=</span> <span class="n">BAMheader</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">SAMheader</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">SAMheader</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_SAMheader_raw</span>

        <span class="c1"># make compatible with pysam attributes, even though the data exists elsewhere</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__references</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">n_refs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__lengths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nreferences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">n_refs</span>

        <span class="k">if</span> <span class="n">check_sq</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_sq</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;No SQ entries in header&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">references</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get all references used in alignment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:py:obj:`tuple` of :py:obj:`str`): reference names</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__references</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nreferences</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get the number of references listed in alignment</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): count of references</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nreferences</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Get all reference lengths used in alignment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:py:obj:`tuple` of :py:obj:`int`): reference lengths</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__lengths</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_truncation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Confusing function to check for file truncation.</span>

<span class="sd">        Every BAM file should contain an EOF signature within the last</span>
<span class="sd">        28 bytes of the file. This function checks for that signature.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (bool): True if truncated, else False</span>

<span class="sd">        Warns:</span>
<span class="sd">            BytesWarning: if no EOF signature found.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">temp_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">28</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">eof</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">temp_pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">eof</span> <span class="o">==</span> <span class="n">bgzf</span><span class="o">.</span><span class="n">_bgzf_eof</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No EOF character found. File may be truncated&#39;</span><span class="p">,</span> <span class="ne">BytesWarning</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pileup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Pileup is not implemented. Consider using `fetch` instead&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="BamReader.has_index">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.has_index">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">has_index</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Checks if file has index and it is open</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if present and opened, else False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span></div>


<div class="viewcode-block" id="BamReader.fetch">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.fetch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fetch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">tid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">until_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">multiple_iterators</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
              <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates a generator that returns all reads within the given region. (inclusive, exclusive)</span>

<span class="sd">        Args:</span>
<span class="sd">            contig (str): name of reference/contig</span>
<span class="sd">            start (int): start position of region of interest (0-based)</span>
<span class="sd">            stop (int): stop position of region of interest (0-based)</span>
<span class="sd">            region (str): SAM region formatted string. Accepts tab-delimited values as well</span>
<span class="sd">            tid (int): the refID or target id of a reference/contig</span>
<span class="sd">            until_eof (bool): iterate until end of file</span>
<span class="sd">            mutiple_iterators (bool): allow multiple iterators over region. Not Implemented. \</span>
<span class="sd">                 Notice: each iterator will open up a new view into the BAM file, so overhead will apply.</span>
<span class="sd">            reference (str): synonym for `contig`</span>
<span class="sd">            end (str): synonym for `stop`</span>

<span class="sd">        Yields:</span>
<span class="sd">            reads over the region of interest if any</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the genomic coordinates are out of range or invalid</span>
<span class="sd">            KeyError: Reference is not found in header</span>

<span class="sd">        Note:</span>
<span class="sd">            SAM region formatted strings take on the following form:</span>
<span class="sd">            &#39;chr1:100000-200000&#39;</span>

<span class="sd">        Usage:</span>
<span class="sd">            .. code-block:: python</span>
<span class="sd">            </span>
<span class="sd">                AlignmentFile.fetch(contig=&#39;chr1&#39;, start=1, stop= 1000)</span>
<span class="sd">                AlignmentFile.fetch(&#39;chr1&#39;, 1, 1000)</span>
<span class="sd">                AlignmentFile.fetch(&#39;chr1:1-1000&#39;)</span>
<span class="sd">                AlignmentFile.fetch(&#39;chr1&#39;, 1)</span>
<span class="sd">                AlignmentFile.fetch(&#39;chr1&#39;)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; next(bam.fetch(&#39;chr1&#39;, 1, 100)) # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">            EAS56_57:6:190:289:82 ... MF:C:192</span>

<span class="sd">            &gt;&gt;&gt; next(bam.fetch(&#39;chr10&#39;, 1, 10))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            KeyError: &#39;chr10 was not found in the file header&#39;</span>

<span class="sd">            &gt;&gt;&gt; next(bam.fetch(&#39;chr1&#39;, 1700, 1701))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            ValueError: Genomic region out of bounds.</span>

<span class="sd">            &gt;&gt;&gt; next(bam.fetch(&#39;chr1&#39;, 100, 10))</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            AssertionError: Malformed region: start should be &lt;= stop, you entered 100, 10</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Inclusive, exclusive. This means if start and stop are</span>
        <span class="c1"># the same, then the user is *essentially* looking at nothing</span>
        <span class="c1"># e.g. a = &quot;abc&quot;; print(a[1:1]) -&gt; &#39;&#39;</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">start</span> <span class="o">==</span> <span class="n">stop</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_access</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Random access not available due to lack of index file&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">multiple_iterators</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;multiple_iterators not yet implemented&#39;</span><span class="p">)</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;multiple_iterators&#39;</span><span class="p">]:</span>
            <span class="n">signature</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">query</span> <span class="o">=</span> <span class="n">parse_region</span><span class="p">(</span><span class="o">**</span><span class="n">signature</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">tid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">query</span><span class="o">.</span><span class="n">contig</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">query</span><span class="o">.</span><span class="n">contig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_reference_name</span><span class="p">(</span><span class="n">tid</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">query</span><span class="o">.</span><span class="n">tid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">query</span><span class="o">.</span><span class="n">contig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2tid</span><span class="p">[</span><span class="n">query</span><span class="o">.</span><span class="n">contig</span><span class="p">]</span> <span class="o">!=</span> <span class="n">tid</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tid and contig name do not match&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">query</span><span class="o">.</span><span class="n">contig</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">query</span><span class="o">.</span><span class="n">tid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">query</span><span class="o">.</span><span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2tid</span><span class="p">[</span><span class="n">query</span><span class="o">.</span><span class="n">contig</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> was not found in the file header&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">contig</span><span class="p">))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">query</span><span class="o">.</span><span class="n">tid</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Genomic region out of bounds.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># set end to length of chromosome</span>
                <span class="n">query</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">query</span><span class="o">.</span><span class="n">tid</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">assert</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="s1">&#39;Malformed region: start should be &lt;= stop, you entered </span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> was not found in the file header&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">contig</span><span class="p">))</span>

        <span class="c1"># from the index, get the virtual offset of the chunk that</span>
        <span class="c1"># begins the overlapping region of interest</span>
        <span class="n">first_read_block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">query</span><span class="o">.</span><span class="n">tid</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">first_read_block</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># move to that virtual offset...should load the block into the cache</span>
        <span class="c1"># if it hasn&#39;t been visited before</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">first_read_block</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">next_read</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">until_eof</span><span class="p">:</span>
                <span class="c1"># check to see if the read is out of bounds of the region</span>
                <span class="c1"># On the wrong contig -&gt; not the right place</span>
                <span class="k">if</span> <span class="n">next_read</span><span class="o">.</span><span class="n">reference_name</span> <span class="o">!=</span> <span class="n">query</span><span class="o">.</span><span class="n">contig</span><span class="p">:</span> 
                    <span class="k">return</span>

                <span class="c1"># Read is too far left -&gt; keep going</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">next_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_read</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># Originates outside, but overlaps</span>
                <span class="k">elif</span> <span class="n">next_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">next_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">next_read</span><span class="o">.</span><span class="n">seq</span><span class="p">)):</span>
                    <span class="k">yield</span> <span class="n">next_read</span>

                <span class="c1"># Read wholly inside region</span>
                <span class="k">elif</span> <span class="n">query</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">next_read</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">next_read</span>

                <span class="c1"># Read too far right -&gt; gotta stop</span>
                <span class="k">elif</span> <span class="n">query</span><span class="o">.</span><span class="n">stop</span> <span class="o">&lt;=</span> <span class="n">next_read</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span>
                    <span class="k">return</span>

                <span class="c1"># check for stop iteration</span>
                <span class="k">elif</span> <span class="n">next_read</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">next_read</span>

                <span class="c1"># Empty read</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span>

            <span class="c1"># Read until the end of file</span>
            <span class="k">else</span><span class="p">:</span> 
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">next_read</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span></div>


<div class="viewcode-block" id="BamReader.count">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.count">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">until_eof</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">tid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">read_callback</span><span class="o">=</span><span class="s1">&#39;nofilter&#39;</span><span class="p">,</span>
              <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Count the number of reads in the given region</span>

<span class="sd">        Note: this counts the number of reads that **overlap** the given region.</span>

<span class="sd">        Can potentially make use of a filter for the reads (or custom function</span>
<span class="sd">        that returns `True` or `False` for each read).</span>

<span class="sd">        Args:</span>
<span class="sd">            contig (str): the reference name (Default: None)</span>
<span class="sd">            reference (str): synonym for `contig` (Default: None)</span>
<span class="sd">            start (int): 0-based inclusive start position (Default: None)</span>
<span class="sd">            stop (int): 0-based exclusive start position (Default: None)</span>
<span class="sd">            end (int): Synonym for `stop` (Default: None)</span>
<span class="sd">            region (str): SAM-style region format. \</span>
<span class="sd">                Example: &#39;chr1:10000-50000&#39; (Default: None)</span>
<span class="sd">            until_eof (bool): count number of reads from start to end of file \</span>
<span class="sd">                Note, this can potentially be an expensive operation. \</span>
<span class="sd">                (Default: False)</span>
<span class="sd">            read_callback (str|function): select (or create) a filter of which \</span>
<span class="sd">                reads to count. Built-in filters:</span>

<span class="sd">                * `all`: skips reads that contain the following flags:</span>

<span class="sd">                    * 0x4 (4): read unmapped</span>
<span class="sd">                    * 0x100 (256): not primary alignment</span>
<span class="sd">                    * 0x200 (512): QC Fail</span>
<span class="sd">                    * 0x400 (1024): PCR or optical duplicate</span>
<span class="sd">                * `nofilter`: uses all reads (Default)</span>
<span class="sd">                * The user can also supply a custom function that \</span>
<span class="sd">                    returns boolean objects for each read</span>
<span class="sd">        Returns:</span>
<span class="sd">            (int): count of reads in the given region that meet parameters</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if genomic coordinates are out of range or invalid or random access is disabled</span>
<span class="sd">            RuntimeError: if `read_callback` is not properly set</span>
<span class="sd">            KeyError: Reference is not found in header</span>
<span class="sd">            AssertionError: if genomic region is malformed</span>

<span class="sd">        Notes:</span>
<span class="sd">            SAM region formatted strings take on the following form:</span>
<span class="sd">            &#39;chr1:100000-200000&#39;</span>

<span class="sd">        Usage:</span>
<span class="sd">                AlignmentFile.count(contig=&#39;chr1&#39;, start=1, stop= 1000)</span>
<span class="sd">                AlignmentFile.count(&#39;chr1&#39;, 1, 1000)</span>
<span class="sd">                AlignmentFile.count(&#39;chr1:1-1000&#39;)</span>
<span class="sd">                AlignmentFile.count(&#39;chr1&#39;, 1)</span>
<span class="sd">                AlignmentFile.count(&#39;chr1&#39;)</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.count(&#39;chr1&#39;, 1, 100)</span>
<span class="sd">            2</span>

<span class="sd">            &gt;&gt;&gt; bam.count(&#39;chr1&#39;, 1, 100, read_callback=&#39;all&#39;)</span>
<span class="sd">            1</span>

<span class="sd">            &gt;&gt;&gt; bam.count(&#39;chr10&#39;, 1, 10)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            KeyError: &#39;chr10 was not found in the file header&#39;</span>

<span class="sd">            &gt;&gt;&gt; bam.count(&#39;chr1&#39;, 1700, 1701)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            ValueError: Genomic region out of bounds.</span>

<span class="sd">            &gt;&gt;&gt; bam.count(&#39;chr1&#39;, 100, 10)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            AssertionError: Malformed region: start should be &lt;= stop, you entered 100, 10</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># pass the signature to fetch</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="n">signature</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;read_callback&#39;</span><span class="p">)</span>
        <span class="n">signature</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;self&#39;</span><span class="p">)</span>
        <span class="n">roi_reads</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="o">**</span><span class="n">signature</span><span class="p">)</span>
        <span class="c1"># make `nofilter` the default filter unless told otherwise</span>
        <span class="c1"># read_callback = kwargs.get(&#39;read_callback&#39;, &#39;nofilter&#39;)</span>

        <span class="c1"># go through all the reads over a given region and count them</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">read</span> <span class="ow">in</span> <span class="n">roi_reads</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filter_read</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">read_callback</span><span class="p">):</span>
                <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">count</span></div>


<div class="viewcode-block" id="BamReader.count_coverage">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.count_coverage">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">count_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">contig</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">region</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">quality_threshold</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">read_callback</span><span class="o">=</span><span class="s1">&#39;all&#39;</span><span class="p">,</span>
                       <span class="n">reference</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">base_quality_threshold</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Counts the coverage of each base supported by a read the given interval.</span>

<span class="sd">        Given an interval (inclusive, exclusive), this method pulls each read that overlaps</span>
<span class="sd">        with the region. To ensure that the read truly overlaps with the region, the CIGAR string</span>
<span class="sd">        is required. These reads can further be filtered out by their flags, MAPQ qualities, or</span>
<span class="sd">        custom filtering function. Using the CIGAR string, the aligned portion of the read</span>
<span class="sd">        is traversed and the presence of each nucleotide base is tallied into respective arrays.</span>
<span class="sd">        Additionally, the user can choose to filter the counted bases based on its base quality</span>
<span class="sd">        score that is stored in the quality string.</span>

<span class="sd">        Args:</span>
<span class="sd">            contig (str): the reference name (Default: None)</span>
<span class="sd">            reference (str): synonym for `contig` (Default: None)</span>
<span class="sd">            start (int): 0-based inclusive start position (Default: None)</span>
<span class="sd">            stop (int): 0-based exclusive start position (Default: None)</span>
<span class="sd">            end (int): Synonym for `stop` (Default: None)</span>
<span class="sd">            region (str): SAM-style region format. \</span>
<span class="sd">                Example: &#39;chr1:10000-50000&#39; (Default: None)</span>
<span class="sd">            quality_threshold (int): MAPQ quality threshold (Default: 15)</span>
<span class="sd">            base_quality_threshold (int): base quality score threshold (Default: 0)</span>
<span class="sd">            read_callback (str|function): select (or create) a filter of which \</span>
<span class="sd">                reads to count. Built-in filters:</span>

<span class="sd">                * `all`: skips reads that contain the following flags:</span>
<span class="sd">                    * 0x4 (4): read unmapped</span>
<span class="sd">                    * 0x100 (256): not primary alignment</span>
<span class="sd">                    * 0x200 (512): QC Fail</span>
<span class="sd">                    * 0x400 (1024): PCR or optical duplicate</span>

<span class="sd">                * `nofilter`: uses all reads (Default)</span>
<span class="sd">                * The user can also supply a custom function that \</span>
<span class="sd">                    returns boolean objects for each read</span>
<span class="sd">        Returns:</span>
<span class="sd">            (:py:obj:`array.array`): Four arrays in the order of **A**, **C**, **G**, **T**</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if genomic coordinates are out of range or invalid, random access is disabled, or nucleotide base is unrecognized</span>
<span class="sd">            RuntimeError: if `read_callback` is not properly set</span>
<span class="sd">            KeyError: Reference is not found in header</span>
<span class="sd">            AssertionError: if genomic region is malformed</span>

<span class="sd">        Notes:</span>
<span class="sd">            SAM region formatted strings take on the following form:</span>
<span class="sd">            &#39;chr1:100-200&#39;</span>

<span class="sd">        Usage:</span>
<span class="sd">                AlignmentFile.count_coverage(contig=&#39;chr1&#39;, start=1, stop= 1000)</span>
<span class="sd">                AlignmentFile.count_coverage(&#39;chr1&#39;, 1, 1000)</span>
<span class="sd">                AlignmentFile.count_coverage(&#39;chr1:1-1000&#39;)</span>
<span class="sd">                AlignmentFile.count_coverage(&#39;chr1&#39;, 1)</span>
<span class="sd">                AlignmentFile.count_coverage(&#39;chr1&#39;)</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; for arr in bam.count_coverage(&#39;chr1&#39;, 100, 150): # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">            ...     print(&quot;array(&#39;{}&#39;, {})&quot;.format(arr.typecode, list(map(int, arr.tolist()))))</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 0, 0, 0, 0, 0])</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 15, 0, 14, 0, 0])</span>
<span class="sd">            array(&#39;L&#39;, [1, 1, 2, 2, ..., 0, 0, 0, 0, 14])</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 0, 15, 0, 14, 0])</span>

<span class="sd">            &gt;&gt;&gt; for arr in bam.count_coverage(&#39;chr1&#39;, 100, 150, quality_threshold=20, base_quality_threshold=25): # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">            ...     print(&quot;array(&#39;{}&#39;, {})&quot;.format(arr.typecode, list(map(int, arr.tolist()))))</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 0, 0, 0, 0, 0])</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 13, 0, 14, 0, 0])</span>
<span class="sd">            array(&#39;L&#39;, [1, 1, 2, 2, ..., 0, 0, 0, 0, 13])</span>
<span class="sd">            array(&#39;L&#39;, [0, 0, 0, 0, ..., 0, 14, 0, 13, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;self&#39;</span><span class="p">,</span> <span class="s1">&#39;quality_threshold&#39;</span><span class="p">,</span> <span class="s1">&#39;read_callback&#39;</span><span class="p">,</span> <span class="s1">&#39;base_quality_threshold&#39;</span><span class="p">]:</span>
            <span class="n">signature</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

        <span class="n">adenine</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">stop</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span>
        <span class="n">cytosine</span> <span class="o">=</span> <span class="n">adenine</span><span class="p">[:]</span>
        <span class="n">guanine</span> <span class="o">=</span> <span class="n">adenine</span><span class="p">[:]</span>
        <span class="n">thymine</span> <span class="o">=</span> <span class="n">adenine</span><span class="p">[:]</span>

        <span class="k">for</span> <span class="n">read</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="o">**</span><span class="n">signature</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">read</span><span class="o">.</span><span class="n">cigarstring</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">read</span><span class="o">.</span><span class="n">mapq</span> <span class="o">&gt;=</span> <span class="n">quality_threshold</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">filter_read</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="n">read_callback</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">base</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">cigar_alignment</span><span class="p">(</span><span class="n">seq</span><span class="o">=</span><span class="n">read</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="n">cigar</span><span class="o">=</span><span class="n">read</span><span class="o">.</span><span class="n">cigarstring</span><span class="p">,</span>
                                                       <span class="n">start_pos</span><span class="o">=</span><span class="n">read</span><span class="o">.</span><span class="n">pos</span><span class="p">,</span> <span class="n">qualities</span><span class="o">=</span><span class="n">read</span><span class="o">.</span><span class="n">query_qualities</span><span class="p">,</span>
                                                       <span class="n">base_qual_thresh</span><span class="o">=</span><span class="n">base_quality_threshold</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">start</span> <span class="o">&lt;=</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">stop</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;A&#39;</span><span class="p">:</span>
                                <span class="n">adenine</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;G&#39;</span><span class="p">:</span>
                                <span class="n">guanine</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;C&#39;</span><span class="p">:</span>
                                <span class="n">cytosine</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="s1">&#39;T&#39;</span><span class="p">:</span>
                                <span class="n">thymine</span><span class="p">[</span><span class="n">index</span> <span class="o">-</span> <span class="n">start</span> <span class="k">if</span> <span class="n">index</span><span class="o">-</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Read base was </span><span class="si">{}</span><span class="s1">, not A, T, C, or G&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">adenine</span><span class="p">,</span> <span class="n">cytosine</span><span class="p">,</span> <span class="n">guanine</span><span class="p">,</span> <span class="n">thymine</span></div>


<div class="viewcode-block" id="BamReader.get_index_stats">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.get_index_stats">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_index_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Inspects the index file (BAI) for alignment statistics.</span>

<span class="sd">        Every BAM index file contains metrics regarding the alignment</span>
<span class="sd">        process for the given BAM file. The stored data are the number</span>
<span class="sd">        of mapped and unmapped reads for a given reference. Unmapped reads</span>
<span class="sd">        are paired end reads where only one part is mapped. Additionally,</span>
<span class="sd">        index files also contain the number of unplaced unmapped reads. This</span>
<span class="sd">        is stored within the `nocoordinate` instance attribute (if present).</span>

<span class="sd">        Returns:</span>
<span class="sd">            idx_stats (:py:obj:`list` of :py:obj:`tuple`): list of tuples for each reference in the order seen in the header. Each tuple contains the number of mapped reads, unmapped reads, and the sum of both.</span>

<span class="sd">        Raises:</span>
<span class="sd">            AssertionError: if the index file is not available</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.get_index_stats()</span>
<span class="sd">            [(1446, 18, 1464), (1789, 17, 1806)]</span>

<span class="sd">            &gt;&gt;&gt; bam_no_bai = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;, index_filename=&#39;not_a_file.bai&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam_no_bai.get_index_stats()</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            AssertionError: No index available</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span><span class="p">,</span> <span class="s1">&#39;No index available&#39;</span>
        <span class="n">idx_stats</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">n_refs</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span><span class="o">.</span><span class="n">n_mapped</span>
                <span class="n">unmapped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index</span><span class="o">.</span><span class="n">unmapped</span><span class="p">[</span><span class="n">ref</span><span class="p">]</span><span class="o">.</span><span class="n">n_unmapped</span>
                <span class="n">idx_stats</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">mapped</span><span class="p">,</span> <span class="n">unmapped</span><span class="p">,</span> <span class="n">mapped</span> <span class="o">+</span> <span class="n">unmapped</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">idx_stats</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">idx_stats</span></div>


<div class="viewcode-block" id="BamReader.is_valid_tid">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.is_valid_tid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_valid_tid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return `True` if TID/RefID is valid.</span>

<span class="sd">        Returns:</span>
<span class="sd">            `True` if TID/refID is valid, else `False`</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.is_valid_tid(0)</span>
<span class="sd">            True</span>

<span class="sd">            &gt;&gt;&gt; bam.is_valid_tid(10) # because there are only 2 in this file</span>
<span class="sd">            False</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">tid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span> <span class="k">else</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="BamReader.get_reference_name">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.get_reference_name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_reference_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert TID/refID to reference name.</span>

<span class="sd">        The TID/refID is the position a reference sequence is seen</span>
<span class="sd">        within the header file of the BAM file. The references are</span>
<span class="sd">        sorted by ASCII order. Therefore, for a **Homo sapien** aligned</span>
<span class="sd">        to GRCh38, &#39;chr10&#39; comes before &#39;chr1&#39; in the header. Therefore,</span>
<span class="sd">        &#39;chr10&#39; would have the TID/refID of 0, not &#39;chr1&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            tid (int): TID/refID of desired reference/contig</span>

<span class="sd">        Returns:</span>
<span class="sd">            String representation of chromosome if valid, else None</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: if TID/refID is not valid</span>

<span class="sd">        Examples:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.get_reference_name(0) # doctest: +ALLOW_UNICODE</span>
<span class="sd">            \&#39;chr1&#39;</span>

<span class="sd">            &gt;&gt;&gt; bam.get_reference_name(10)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            KeyError: &#39;10 is not a valid TID/refID for this file.&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_valid_tid</span><span class="p">(</span><span class="n">tid</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">refs</span><span class="p">[</span><span class="n">tid</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> is not a valid TID/refID for this file.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tid</span><span class="p">))</span></div>


<div class="viewcode-block" id="BamReader.get_tid">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.get_tid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_tid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reference</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert reference/contig name to refID/TID.</span>

<span class="sd">        The TID/refID is the position a reference sequence is seen</span>
<span class="sd">        within the header file of the BAM file. The references are</span>
<span class="sd">        sorted by ASCII order. Therefore, for a **Homo sapien** aligned</span>
<span class="sd">        to GRCh38, &#39;chr10&#39; comes before &#39;chr1&#39; in the header. Therefore,</span>
<span class="sd">        &#39;chr10&#39; would have the TID/refID of 0, not &#39;chr1&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            reference (str): reference/contig name</span>

<span class="sd">        Returns:</span>
<span class="sd">            (int): the TID/refID of desired reference/contig</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: if reference name not found file header</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.get_tid(&#39;chr1&#39;)</span>
<span class="sd">            0</span>

<span class="sd">            &gt;&gt;&gt; bam.get_tid(&#39;chr10&#39;)</span>
<span class="sd">            Traceback (most recent call last):</span>
<span class="sd">                ...</span>
<span class="sd">            KeyError: &#39;chr10 was not found in the file header&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">tid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref2tid</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> was not found in the file header&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">reference</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tid</span></div>


<div class="viewcode-block" id="BamReader.mate">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.mate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">AlignedSegment</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Gets the mate to a given AlignedSegment.</span>

<span class="sd">        Note:</span>
<span class="sd">            Slow, when compared to the C-API. Not meant for high-throughput analysis.</span>

<span class="sd">        Does not advance current iterator position.</span>

<span class="sd">        Args:</span>
<span class="sd">            AlignedSegment (:py:class:`bamnostic.AlignedSegment`): a bamnostic AlignedSegment read with a mate</span>

<span class="sd">        Returns:</span>
<span class="sd">            (:py:class:`bamnostic.AlignedSegment`): if read has a valid mate, else None</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if AlignedSegment is unpaired</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="n">bamnostic</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">index_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">mate_head</span><span class="p">:</span>

            <span class="c1"># Don&#39;t look if there isn&#39;t a pair</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">AlignedSegment</span><span class="o">.</span><span class="n">is_paired</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Read is unpaired&#39;</span><span class="p">)</span>

            <span class="c1"># Based on standard convention</span>
            <span class="n">read_name_base</span> <span class="o">=</span> <span class="n">read_name_pat</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">AlignedSegment</span><span class="o">.</span><span class="n">read_name</span><span class="p">)</span><span class="o">.</span><span class="n">groupdict</span><span class="p">()[</span><span class="s1">&#39;read_name&#39;</span><span class="p">]</span>
            <span class="n">rnext</span> <span class="o">=</span> <span class="n">AlignedSegment</span><span class="o">.</span><span class="n">next_reference_id</span>

            <span class="c1"># Look for available mate information</span>
            <span class="k">if</span> <span class="n">rnext</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Information is unavailable</span>
            <span class="n">pnext</span> <span class="o">=</span> <span class="n">AlignedSegment</span><span class="o">.</span><span class="n">next_reference_start</span>
            <span class="k">if</span> <span class="n">pnext</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no information available on read</span>

            <span class="n">mate_gen</span> <span class="o">=</span> <span class="n">mate_head</span><span class="o">.</span><span class="n">fetch</span><span class="p">(</span><span class="n">tid</span><span class="o">=</span><span class="n">rnext</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">pnext</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">pnext</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">read</span> <span class="ow">in</span> <span class="n">mate_gen</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">read</span><span class="o">.</span><span class="n">read_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">read_name_base</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">AlignedSegment</span><span class="o">.</span><span class="n">is_read1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">read</span><span class="o">.</span><span class="n">is_read1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">read</span></div>


<div class="viewcode-block" id="BamReader.head">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.head">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">head</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">multiple_iterators</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; List out the first **n** reads of the file.</span>

<span class="sd">        This method is primarily used when doing an initial exploration</span>
<span class="sd">        of the data. Whether or not `multiple_iterators` is used, cursor</span>
<span class="sd">        position within the file will not change.</span>

<span class="sd">        Note:</span>
<span class="sd">            Using `multiple_interators` opens a new file object of the</span>
<span class="sd">            same file currently in use and, thus, impacts the memory</span>
<span class="sd">            footprint of your analysis.</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): number of aligned reads to print (default: 5)</span>
<span class="sd">            mutliple_iterators (bool): Whether to use current file object or create a new one (default: False).</span>

<span class="sd">        Returns:</span>
<span class="sd">            head_reads (:py:obj:`list` of :py:obj:`AlignedSegment`): list of **n** reads from the front of the BAM file</span>

<span class="sd">        Example:</span>
<span class="sd">            &gt;&gt;&gt; bam = bamnostic.AlignmentFile(bamnostic.example_bam, &#39;rb&#39;)</span>
<span class="sd">            &gt;&gt;&gt; bam.head(n=5, multiple_iterators = False)[0] # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">            EAS56_57:6:190:289:82	...	MF:C:192</span>

<span class="sd">            &gt;&gt;&gt; bam.head(n = 5)[1] # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE</span>
<span class="sd">            EAS56_57:6:190:289:82	...	UQ:C:0</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">multiple_iterators</span><span class="p">:</span>
            <span class="n">head_iter</span> <span class="o">=</span> <span class="n">bamnostic</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">index_filename</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_index_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">curr_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="c1"># BAMheader uses byte specific positions (and not BGZF virtual offsets)</span>
<span class="c1">#             self._handle.seek(self._header._BAMheader_end)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_header</span><span class="o">.</span><span class="n">_BAMheader_end</span><span class="p">)</span>
            <span class="n">head_iter</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="n">head_reads</span> <span class="o">=</span> <span class="p">[</span><span class="nb">next</span><span class="p">(</span><span class="n">head_iter</span><span class="p">)</span> <span class="k">for</span> <span class="n">read</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">multiple_iterators</span><span class="p">:</span>
            <span class="c1"># close the independent file object</span>
            <span class="n">head_iter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise, just go back to old position</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">curr_pos</span><span class="p">)</span>
            <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span> <span class="o">==</span> <span class="n">curr_pos</span>
        <span class="k">return</span> <span class="n">head_reads</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the next line (Py2 Compatibility).&quot;&quot;&quot;</span>

        <span class="n">read</span> <span class="o">=</span> <span class="n">bamnostic</span><span class="o">.</span><span class="n">AlignedSegment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">read</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span>
        <span class="k">return</span> <span class="n">read</span>

<div class="viewcode-block" id="BamReader.next">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.next">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the next line.&quot;&quot;&quot;</span>

        <span class="n">read</span> <span class="o">=</span> <span class="n">bamnostic</span><span class="o">.</span><span class="n">AlignedSegment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">read</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="n">read</span></div>


<div class="viewcode-block" id="BamReader.seekable">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamReader.seekable">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">seekable</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True indicating the BGZF supports random access.</span>

<span class="sd">        Note:</span>
<span class="sd">            Modified from original Bio.BgzfReader: checks to see if BAM</span>
<span class="sd">            file has associated index file (BAI)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_idx</span></div>
</div>



<span class="k">def</span><span class="w"> </span><span class="nf">_sam_header_to_ref_list</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Modified code from Peter Cock&#39;s [BamWriter](https://github.com/peterjc/biopython/blob/SamBam2015/Bio/Sequencing/SamBam/__init__.py#L1714)</span>

<span class="sd">    Removes blank lines, ensures trailing newlines, spots some errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;@SQ</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">l</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;SN:&quot;</span><span class="p">):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="n">part</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
                <span class="k">elif</span> <span class="n">part</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;LN:&quot;</span><span class="p">):</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="mi">3</span><span class="p">:])</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Malformed @SQ header (SN and LN required):</span><span class="se">\n</span><span class="si">%r</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
            <span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">references</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_ref_list_to_sam_header</span><span class="p">(</span><span class="n">references</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Modified code from Peter Cock&#39;s [BamWriter](https://github.com/peterjc/biopython/blob/SamBam2015/Bio/Sequencing/SamBam/__init__.py#L1714)</span>

<span class="sd">    Removes blank lines, ensures trailing newlines, spots some errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot;@SQ</span><span class="se">\t</span><span class="s2">SN:</span><span class="si">%s</span><span class="se">\t</span><span class="s2">LN:</span><span class="si">%i</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">)</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span> <span class="ow">in</span> <span class="n">references</span><span class="p">])</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_check_header_text</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Modified code from Peter Cock&#39;s [BamWriter](https://github.com/peterjc/biopython/blob/SamBam2015/Bio/Sequencing/SamBam/__init__.py#L1714)</span>

<span class="sd">    Removes blank lines, ensures trailing newlines, spots some errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">continue</span>
            <span class="c1"># raise ValueError(&quot;Blank line in header&quot;)</span>
        <span class="k">elif</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;@&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;SAM header lines must start with @, not </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">line</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_cross_check_header_refs</span><span class="p">(</span><span class="n">reads</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">referencenames</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">referencelengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Modified code from Peter Cock&#39;s [BamWriter](https://github.com/peterjc/biopython/blob/SamBam2015/Bio/Sequencing/SamBam/__init__.py#L1714)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">header</span><span class="p">:</span>
        <span class="c1"># If the reads argument is a SamIterator or BamIterator this works:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">reads</span><span class="o">.</span><span class="n">text</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">if</span> <span class="n">referencenames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">referencelengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">referencenames</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">referencelengths</span><span class="p">)</span>
        <span class="n">references</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">referencenames</span><span class="p">,</span> <span class="n">referencelengths</span><span class="p">)</span>
        <span class="n">alt_refs</span> <span class="o">=</span> <span class="n">_sam_header_to_ref_list</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">alt_refs</span><span class="p">:</span>
            <span class="c1"># Append minimal @SQ lines to the header</span>
            <span class="n">header</span> <span class="o">+=</span> <span class="n">_ref_list_to_sam_header</span><span class="p">(</span><span class="n">references</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">alt_refs</span> <span class="o">!=</span> <span class="n">references</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reference names and lengths inconsistent with header @SQ lines&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">references</span> <span class="o">=</span> <span class="n">_sam_header_to_ref_list</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">header</span><span class="p">,</span> <span class="n">references</span>


<div class="viewcode-block" id="BamWriter">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamWriter">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">BamWriter</span><span class="p">(</span><span class="n">bgzf</span><span class="o">.</span><span class="n">BgzfWriter</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;xb&#39;</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="mi">6</span><span class="p">,</span> <span class="n">ignore_overwrite</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                <span class="n">copy_header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">reference_names</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reference_lengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Useful class for writing BAM files. </span>

<span class="sd">        Note:</span>
<span class="sd">            As of right now, it is tuned for working within a pipeline where reads </span>
<span class="sd">            are being filtered or modified from another BAM file.</span>

<span class="sd">        Args:</span>
<span class="sd">            filepath_or_object (str | :py:obj:`file`): the path or file object of the BAM file</span>
<span class="sd">            mode (str): Mode for writing. BAM files are binary by nature (default: &#39;xb&#39;)</span>
<span class="sd">            compresslevel (int): desired level of Gzip compression (default: 6)</span>
<span class="sd">            ignore_overwrite (bool): whether or not to ignore overwrite detection</span>
<span class="sd">            copy_header (filepath_or_object): copy the header from another BAM file</span>
<span class="sd">            header (bytes): SAM-style header</span>
<span class="sd">            reference_names (:py:obj:`list` of :py:obj:`str`): list of all reference names used in file</span>
<span class="sd">            reference_lengths (:py:obj:`list` of :py:obj:`int`): list of all reference lengths used in file</span>

<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="s1">&#39;b&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;BAM files must be written in binary mode, try &#39;</span><span class="si">{}</span><span class="s2">b&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="s1">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;bamnostic.bam.BamWriter cannot operate in reading (r) mode&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>

            <span class="c1"># Make sure the user knows they will be overwriting the data</span>
            <span class="k">if</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ignore_overwrite</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">yes_no</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> already exists. Going further will overwrite the file&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">)):</span>
                    <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">compresslevel</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">FileExistsError</span><span class="p">(</span><span class="s1">&#39;User declined overwrite&#39;</span><span class="p">)</span>

            <span class="c1"># If they know beforehand, let them overwrite</span>
            <span class="k">elif</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">and</span> <span class="n">ignore_overwrite</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">compresslevel</span><span class="p">)</span>

            <span class="c1"># Just a new file</span>
            <span class="k">elif</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">compresslevel</span><span class="p">)</span>

            <span class="c1"># Pluck off the EOF block for appended files and make sure to not re-write header</span>
            <span class="k">elif</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="s1">&#39;r+&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">appended</span><span class="p">:</span>
                    <span class="n">appended</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="mi">28</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_END</span><span class="p">)</span>
                    <span class="n">appended</span><span class="o">.</span><span class="n">truncate</span><span class="p">()</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">compresslevel</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="c1"># All other options</span>
            <span class="k">elif</span> <span class="s1">&#39;x&#39;</span> <span class="ow">in</span> <span class="n">mode</span> <span class="ow">or</span> <span class="s1">&#39;+&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span> <span class="o">=</span> <span class="n">compresslevel</span><span class="p">)</span>

                <span class="c1"># Make sure to not re-write header</span>
                <span class="k">if</span> <span class="s1">&#39;r&#39;</span> <span class="ow">in</span> <span class="n">mode</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># If they already opened the file, let them do whatever they want</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">io</span><span class="o">.</span><span class="n">IOBase</span><span class="p">):</span>
            <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath_or_object</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">compresslevel</span><span class="o">=</span><span class="n">compresslevel</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_header</span><span class="p">(</span><span class="n">copy_header</span> <span class="o">=</span> <span class="n">copy_header</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="p">,</span> 
                        <span class="n">reference_names</span> <span class="o">=</span> <span class="n">reference_names</span><span class="p">,</span> 
                        <span class="n">reference_lengths</span> <span class="o">=</span> <span class="n">reference_lengths</span><span class="p">)</span>

<div class="viewcode-block" id="BamWriter.write_header">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamWriter.write_header">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">copy_header</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">header</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">reference_names</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reference_lengths</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Modified code from Peter Cock&#39;s [BamWriter](https://github.com/peterjc/biopython/blob/SamBam2015/Bio/Sequencing/SamBam/__init__.py#L1714)</span>

<span class="sd">        Writes the header into a BAM file</span>

<span class="sd">        Args:</span>
<span class="sd">            copy_header (filepath_or_object): copy the header from another BAM file</span>
<span class="sd">            header (bytes): SAM-style header</span>
<span class="sd">            reference_names (:py:obj:`list` of :py:obj:`str`): list of all reference names used in file</span>
<span class="sd">            reference_lengths (:py:obj:`list` of :py:obj:`int`): list of all reference lengths used in file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">copy_header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">copy_header</span><span class="p">,</span> <span class="n">bamnostic</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">AlignmentFile</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;From bam&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">bgzf</span><span class="o">.</span><span class="n">get_block</span><span class="p">(</span><span class="n">copy_header</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_handle</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">reference_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">reference_lengths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reference_lengths</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s1">&#39;Reference names and reference lengths must be equal is size&#39;</span><span class="p">)</span>
            <span class="n">header</span><span class="p">,</span> <span class="n">references</span> <span class="o">=</span> <span class="n">_cross_check_header_refs</span><span class="p">(</span><span class="n">reads</span><span class="p">,</span>
                                                        <span class="n">header</span><span class="p">,</span>
                                                        <span class="n">reference_names</span><span class="p">,</span>
                                                        <span class="n">reference_lengths</span><span class="p">)</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">_as_bytes</span><span class="p">(</span><span class="n">_check_header_text</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
            <span class="c1"># Write BAM header:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">_bam_magic</span><span class="p">)</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)))</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">references</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">r</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">references</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">_as_bytes</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="n">_null_byte</span><span class="p">)</span>
                    <span class="n">handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">struct</span><span class="o">.</span><span class="n">pack</span><span class="p">(</span><span class="s2">&quot;&lt;I&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Problem with reference </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">l</span><span class="p">))</span>

            <span class="c1"># Want to give it its own BGZF block, even if there is no SAM header:</span>
            <span class="n">handle</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span></div>


<div class="viewcode-block" id="BamWriter.write">
<a class="viewcode-back" href="../../bamnostic.html#bamnostic.bam.BamWriter.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">65536</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">BamWriter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2018, Marcus D. Sherman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>